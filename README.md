# Agent Comparison Series 02 - Hermes

This repository is part of a small series of complex development tasks used to compare different AI agents and orchestration approaches.

This is **not** an automated benchmark and it does **not** provide automatic scoring.
Instead, human developers are expected to inspect the output, review the code quality, test the UX, and decide which agent best fits their own expectations and workflows.

Software engineering is inherently personal.
The goal of this series is to provide **rich, realistic development scenarios** that allow each person to form their *own* opinion about agent behavior, reasoning ability, reliability, and architectural competence.

The `main` branch always contains the givens for the task — typically a `prompt.md` and minimal boilerplate.
Additional branches represent **outputs of individual agent runs**, such as results generated by different coding agents or orchestration frameworks (e.g., spec-kit, openspec, bmad, code-centric agents, etc.).

---

# Comparison 02 – Early Text Generation Playground

This scenario asks the agent to build a **modern, interactive web application** that teaches laypeople the earliest ideas behind text-based generative AI.

The app should introduce users to three fundamental historical concepts:

1. **N-gram models** — the classic statistical method of predicting the next token based on the previous `n-1` tokens.
2. **Text generation via genetic algorithm** — evolving sentences or text candidates through mutation, crossover, and fitness scoring.
3. **A third “mystery lab” concept chosen by the agent** — an important early or foundational idea in text generation, explained interactively with visualizations and user-tunable parameters.

The goal is **education through experimentation**: users should be able to tweak sliders, generate text, observe outputs, and read simple explanations of what is happening behind the scenes.

## High-Level App Requirements

At a high level, the app should:

* Provide a **state-of-the-art UI** (modern SPA, clean aesthetic, responsive design).
* Include separate labs for:

  * N-gram modeling (with visualizations, user corpora, token statistics, and generation controls).
  * Genetic-algorithm-based text generation (population, fitness curves, mutation sliders, etc.).
  * A third concept determined by the agent (beam search, sampling strategies, Markov chains, tiny RNN demo, etc.).
* Provide clear, beginner-friendly explanations throughout the UI.
* Make the educational aspect primary: users should both *understand* and *experience* how early text generation worked before neural LMs.

## Key UX Features

* A polished single-page app with a landing page and three “labs”.
* Rich interactivity:

  * Sliders for parameters (n size, mutation rate, population size, etc.).
  * Generation buttons with animated feedback.
  * Charts for n-gram counts, GA fitness over time, or other method-specific graphs.
* Real-time output and visualization updates based on user input.
* Short, readable explanations next to every interactive element.
* A clear structure:

  * “What is this?”
  * “Try it!”
  * “What did you observe?”

## Technical Constraints

* Modern front-end stack (React + TypeScript recommended; agent may choose any widely adopted state-of-the-art equivalent).
* Clean component architecture and maintainable code.
* Client-side computation is preferred for n-grams and GA; backends are allowed but should stay lightweight.
* Document design choices in the README produced by the agent.
* Add minimal tests validating core algorithms (e.g., n-gram generation, GA steps, sampling logic).

## Evaluation Method

As with the other tasks in this series, the evaluation is **qualitative**:

* How well did the agent understand the educational goal?
* How polished, coherent, and maintainable is the UI and code structure?
* Does the UX actually help laypeople understand the underlying concepts?
* Are the explanations technically correct yet beginner-friendly?
* Is the agent capable of building non-trivial logic (n-grams, GA) and wiring it cleanly into a modern SPA?

There is intentionally **no single correct solution**.
Different agents will produce different architectures, design patterns, and UI aesthetics — which is exactly what this series aims to reveal.

For the precise specification and authoritative requirements, see **`prompt.md`** in this branch.

